<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Load Chart.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <!-- Load Chart.js Data Labels plugin from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <!-- Load Chart.js Date Adapter plugin from CDN to handle date/time on the x-axis -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Load Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        * {
            box-sizing: border-box; /* Include padding and border in element's total width and height */
            padding: 0;
            margin: 0;
        }

        /* Main dashboard layout */

        main {
            background-color: rgb(230, 230, 230);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            gap: 20px;
        }

        h2 {
            padding-top: 10px;
        }

        /* Section-1 layout, statusCard + barCHart + pieChart */

        .charts-container-1 {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        @media (min-width: 815px) {
            .charts-container-1 {
                flex-direction: row;
            }
        }
        @media (max-width: 815px) {
            .charts-container-1 {
                flex-direction: column;
            }
        }

        .pieChart-container {
            width: 280px;
            height: 370px;
        }

        .barChart-container {
            width: 500px;
            height: 370px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* statusCard style */
        .status-cards-container {
            width: 100%;
            max-width: 500px;
            display: grid;
            grid-template-columns: repeat(auto-fit, 240px);
            gap: 20px;
            justify-content: center;
            padding-bottom: 15px;
        }

        .status-card {
            border-radius: 8px;
            padding: 25px;
            color: white;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s ease;
        }

        .status-card:hover {
            transform: translateY(-5px);
        }

        .card-icon i {
            font-size: 40px;
        }

        .card-content h3 {
            margin: 0;
            font-size: 32px;
            font-weight: bold;
        }

        .card-content p {
            margin: 5px 0 0 0;
            font-size: 16px;
            opacity: 0.9;
        }

        /* coloring the statusCards */
        .card-online {
            background: linear-gradient(135deg, #20bf6b, #26d07c);
        }

        .card-engine {
            background: linear-gradient(135deg, #fa8231, #fc9952);
        }

        .card-ack {
            background: linear-gradient(135deg, #003cff, #3366ff);
        }

        .card-offline {
            background: linear-gradient(135deg, #ff0000, #ff3333);
        }

        /* Section-2 layout, barCHartHorizontal + lineChart */

        .charts-container-2 {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        @media (min-width: 900px) {
            .charts-container-2 {
                flex-direction: row;
            }
        }
        @media (max-width: 900px) {
            .charts-container-2 {
                flex-direction: column;
            }
        }

        /* Base styles for <560px (adjust as needed) */
        .barChartHorizontal-container, .lineChart-container {
            width: 420px;
            height: 230px;
        }
        /* Mid-range: 560px to 900px */
        @media (min-width: 560px) {
            .barChartHorizontal-container, .lineChart-container {
                width: 550px;
                height: 260px;
            }
        }
        /* Large screens: 900px+ */
        @media (min-width: 900px) {
            .barChartHorizontal-container, .lineChart-container {
                width: 445px;
                height: 230px;
            }
        }
    </style>
</head>

<body>
    <main>
        <h2>État des véhicules</h2>
        <div class="status-cards-container"></div>
        <div class="charts-container-1">
            <div class="pieChart-container">
                <canvas id="pieChart"></canvas>
            </div>
            <div class="barChart-container">
                <canvas id="barChart"></canvas>
            </div>
        </div>

        <h2>Aperçu des alertes</h2>
        <div class="charts-container-2">
            <div class="barChartHorizontal-container">
                <canvas id="barChartHorizontal"></canvas>
            </div>
            <div class="lineChart-container">
                <canvas id="lineChart"></canvas>
            </div>
        </div>
    </main>
</body>

<script>
    const statusData = {
        "online": {
            label: 'En mouvement',
            value: 85,
            color: '#20bf6b',
            icon: 'fas fa-car-side'
        },
        "engine": {
            label: 'Non confirmé',
            value: 5,
            color: '#fa8231',
            icon: 'fa-solid fa-gear'
        },
        "ack": {
            label: 'À l\'arrêt - Confirmé',
            value: 190,
            color: '#003cff',
            icon: 'fa-solid fa-satellite-dish'
        },
        "offline": {
            label: 'Hors ligne',
            value: 1620,
            color: '#ff0000',
            icon: 'fa-solid fa-ban'
        }
    };

    const alertsData = [ // similar to "events.data" in the events' index page in ostool, but with only "occurred_at" and "id" properties for simplicity
        {
            "id": 315,
            "type": "distance",
            "occurred_at": "2026-02-05T07:36:07.000000Z"
        },{
            "id": 312,
            "type": "distance",
            "occurred_at": "2026-02-04T07:49:27.000000Z"
        },{
            "id": 314,
            "type": "distance",
            "occurred_at": "2026-02-05T07:52:47.000000Z"
        },{
            "id": 313,
            "type": "distance",
            "occurred_at": "2026-02-04T08:32:27.000000Z"
        },{
            "id": 791,
            "type": "geofence_in",
            "occurred_at": "2026-02-04T08:35:16.000000Z"
        },{
            "id": 311,
            "type": "geofence_in",
            "occurred_at": "2026-02-04T09:14:56.000000Z"
        },{
            "id": 892,
            "type": "geofence_in",
            "occurred_at": "2026-02-04T09:36:16.000000Z"
        },{
            "id": 309,
            "type": "geofence_in",
            "occurred_at": "2026-02-04T10:07:46.000000Z"
        },{
            "id": 310,
            "type": "geofence_in",
            "occurred_at": "2026-02-04T10:09:36.000000Z"
        },{
            "id": 294,
            "type": "geofence_in",
            "occurred_at": "2026-02-04T10:37:06.000000Z"
        },{
            "id": 293,
            "type": "geofence_inout",
            "occurred_at": "2026-02-04T11:36:46.000000Z"
        },{
            "id": 296,
            "type": "geofence_inout",
            "occurred_at": "2026-02-04T11:38:36.000000Z"
        },{
            "id": 299,
            "type": "geofence_out",
            "occurred_at": "2026-02-04T12:13:06.000000Z"
        },{
            "id": 303,
            "type": "geofence_out",
            "occurred_at": "2026-02-04T12:30:56.000000Z"
        },{
            "id": 300,
            "type": "geofence_out",
            "occurred_at": "2026-02-04T14:16:26.000000Z"
        },{
            "id": 304,
            "type": "geofence_out",
            "occurred_at": "2026-02-04T14:33:46.000000Z"
        },{
            "id": 305,
            "type": "geofence_out",
            "occurred_at": "2026-02-04T14:36:46.000000Z"
        },{
            "id": 298,
            "type": "geofence_out",
            "occurred_at": "2026-02-04T15:10:36.000000Z"
        },{
            "id": 297,
            "type": "idle_duration",
            "occurred_at": "2026-02-04T15:20:06.000000Z"
        },{
            "id": 693,
            "type": "idle_duration",
            "occurred_at": "2026-02-04T15:30:16.000000Z"
        },{
            "id": 392,
            "type": "idle_duration",
            "occurred_at": "2026-02-04T15:35:16.000000Z"
        },{
            "id": 591,
            "type": "ignition",
            "occurred_at": "2026-02-04T12:40:16.000000Z"
        },{
            "id": 391,
            "type": "ignition",
            "occurred_at": "2026-02-04T15:45:16.000000Z"
        },{
            "id": 493,
            "type": "ignition",
            "occurred_at": "2026-02-04T15:50:16.000000Z"
        },{
            "id": 492,
            "type": "ignition",
            "occurred_at": "2026-02-04T15:55:16.000000Z"
        },{
            "id": 491,
            "type": "ignition_duration",
            "occurred_at": "2026-02-04T15:59:16.000000Z"
        },{
            "id": 308,
            "type": "ignition_duration",
            "occurred_at": "2026-02-04T16:10:26.000000Z"
        },{
            "id": 307,
            "type": "ignition_duration",
            "occurred_at": "2026-02-04T16:20:36.000000Z"
        },{
            "id": 306,
            "type": "move_duration",
            "occurred_at": "2026-02-04T16:30:26.000000Z"
        },{
            "id": 302,
            "type": "move_duration",
            "occurred_at": "2026-02-04T16:36:56.000000Z"
        },{
            "id": 301,
            "type": "move_duration",
            "occurred_at": "2026-02-05T17:20:06.000000Z"
        },{
            "id": 295,
            "type": "move_duration",
            "occurred_at": "2026-02-04T17:38:06.000000Z"
        }
    ]

    // Extract status, values, colors, and icons dynamically, so later we just change the statusData to update all charts and cards for a new dashboard
    const status = Object.keys(statusData); // ["online", "engine", "ack", "offline"]
    const dataLabels = Object.values(statusData).map(item => item.label); // ['En mouvement', 'Non confirmé', 'À l\'arrêt - Confirmé', 'Hors ligne']
    const dataValues = Object.values(statusData).map(item => item.value); // [85, 5, 190, 1620]
    const dataColors = Object.values(statusData).map(item => item.color); // ['#20bf6b', '#fa8231', '#003cff', '#ff0000']
    const dataIcons = Object.values(statusData).map(item => item.icon); // ['fa-check-circle', 'fa-cog', 'fa-bell', 'fa-times-circle']

    let myPieChart // store the pie chart instance
    renderPieChart(dataLabels, dataValues, dataColors);

    let myBarChart // store the bar chart instance
    renderBarChart(dataLabels, dataValues, dataColors);

    renderStatusCards(status, dataLabels, dataValues, dataIcons);

    // Generate status cards dynamically
    function renderStatusCards(status, dataLabels, dataValues, dataIcons) {
        const container = document.querySelector('.status-cards-container');

        // Clear existing cards to prevent duplicates
        container.innerHTML = '';
        
        for(let i = 0; i < status.length; i++) {
            const currentStatus = status[i];
            const label = dataLabels[i];
            const count = dataValues[i];
            const icon = dataIcons[i];
    
            const card = document.createElement('div');
            card.className = `status-card card-${currentStatus}`;
            card.innerHTML = `
                <div class="card-icon">
                    <i class="${icon}"></i>
                </div>
                <div class="card-content">
                    <h3>${count}</h3>
                    <p>${label.charAt(0).toUpperCase() + label.slice(1)}</p> <!-- Capitalize first letter + the rest of the word -->
                </div>
            `;
            container.appendChild(card);
        }
    }

    // Pie Chart
    function renderPieChart(dataLabels, dataValues, dataColors) {
        const ctxPie = document.getElementById('pieChart').getContext('2d');

        // If chart already exists, update data and redraw
        if(myPieChart) {
            myPieChart.data.labels = dataLabels;
            myPieChart.data.datasets[0].data = dataValues;
            myPieChart.data.datasets[0].backgroundColor = dataColors;
            myPieChart.update(); // Triggers re-render
            return;
        }
        
        myPieChart = new Chart(ctxPie, {
            type: 'doughnut', // This can also be 'pie'
            data: {
                labels: dataLabels,
                datasets: [{
                    label: 'Status Count',
                    data: dataValues,
                    backgroundColor: dataColors,
                    borderWidth: 1
                }]
            },
            options: {
                maintainAspectRatio: false, // Allow chart to resize based on container (so it can use thefull containers height when we add paddings to the title and legend)
                layout: {
                    padding: {
                        // Optional: add padding around the chart
                    }
                },
                onClick: (event, activeElements) => {
                    if (activeElements.length > 0) { // checks if there are any active elements (slices)
                        const index = activeElements[0].index; // Get the index of the clicked slice
                        const clickedStatus = status[index]; // Get the corresponding status of the clicked slice
                        
                        const params = new URLSearchParams({
                            currentStatus: clickedStatus,
                            // add other parameters as needed
                        });
                        window.location.href = `dashboardTemplate.html?${params.toString()}`; // Navigate to the live monitoring page with query parameters
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Pourcentage de la flotte par statut',
                        padding: {
                            bottom: 10
                        }
                    },
                    legend: {
                        display: true, // Enable legend for pie charts
                        position: 'bottom', // Optional: position the legend
                        padding: {
                            // only controls spacing between individual legend items, not the gap between the legend box and the chart itself.à
                        }
                    },
                    datalabels: { // Configuration for Data Labels plugin
                        anchor: 'end', // Position at the edge of the slice
                        align: 'end', // Push labels away from the anchor point
                        offset: -4, // Add spacing between slice and label
                        color: '#000',
                        formatter: (value, context) => {
                            // Calculate total of all data points
                            const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                            // Calculate percentage
                            const percentage = (value / total * 100);
    
                            if(percentage < 1) {
                                return ''; // Don't display labels who are les than 1%
                            }
    
                            // return the percentage as a string with a '%' sign
                            return percentage.toFixed(1) + '%';
                        }
                    }
                }
            },
            // When we include the Data Labels plugin CDN script, it creates a global variable
            // called "ChartDataLabels" that we need to register with the chart.
            plugins: [ChartDataLabels] // Register the Data Labels plugin
        });
    }

    // Bar Chart
    function renderBarChart(dataLabels, dataValues, dataColors) {
        const ctxBar = document.getElementById('barChart').getContext('2d');

        // If chart already exists, update data and redraw
        if(myBarChart) {
            myBarChart.data.labels = dataLabels;
            myBarChart.data.datasets[0].data = dataValues;
            myBarChart.data.datasets[0].backgroundColor = dataColors;
            myBarChart.update(); // Triggers re-render
            return;
        }

        myBarChart = new Chart(ctxBar, {
            type: 'bar', // Specify bar chart type
            data: {
                labels: dataLabels,
                datasets: [{
                    label: 'Status Count', // This dataset label is what Chart.js uses when it generates
                    // the legend entries and also what appears in tooltips. However, since we have only
                    // one dataset, it may not be necessary to display it, so below in
                    // "options > plugings" we're hiding the legend.
                    data: dataValues,
                    backgroundColor: dataColors,
                    borderWidth: 1
                }]
            },
            options: {
                onClick: (event, activeElements) => {
                    if (activeElements.length > 0) { // checks if there are any active elements (slices)
                        const index = activeElements[0].index; // Get the index of the clicked slice
                        const clickedStatus = status[index]; // Get the corresponding status of the clicked slice
                        
                        const params = new URLSearchParams({
                            currentStatus: clickedStatus,
                            // add other parameters as needed
                        });
                        window.location.href = `dashboardTemplate.html?${params.toString()}`; // Navigate to the live monitoring page with query parameters
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Répartition des statuts'
                    },
                    legend: {
                        display: false // Hide legend since we have only one dataset
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true, // Ensure the y-axis starts at zero
                        title: {
                            display: true,
                            text: 'Nombre de véhicules'
                        }
                    }
                }
            }
        });
    }

    const alertsDataTypes = getAlertsDataTypes(alertsData); // e.g. { distance: 4, geofence_in: 6, ... }

    const sortedAlertsDataTypes = sortAlertsDescending(alertsDataTypes); // e.g. { geofence_in: 6, distance: 4, ... }

    // Extract labels and values dynamically
    const alertsLabels = Object.keys(sortedAlertsDataTypes); // ["distance", "geofence_in", "ignition", ...]
    const alertsDataValues = Object.values(sortedAlertsDataTypes); // [6, 4, 2, ...]

    let myBarChartHorizontal // store the horizontal bar chart instance
    renderBarChartHorizontal(alertsLabels, alertsDataValues);

    function renderBarChartHorizontal(alertsLabels, alertsDataValues){
        const ctxBarHorizontal = document.getElementById('barChartHorizontal').getContext('2d');

        // If chart already exists, update data and redraw
        if(myBarChartHorizontal) {
            myBarChartHorizontal.data.labels = dataLabels;
            myBarChartHorizontal.data.datasets[0].data = dataValues;
            myBarChartHorizontal.data.datasets[0].backgroundColor = dataColors;
            myBarChartHorizontal.update(); // Triggers re-render
            return;
        }

        // Create a vertical gradient color for the bars
        const purpleGradient = ctxBarHorizontal.createLinearGradient(0, 0, 0, 400);
        purpleGradient.addColorStop(0, '#8456CE'); // Top color
        purpleGradient.addColorStop(1, 'rgba(132, 86, 206, 0.4)'); // Bottom color (faded)
        
        myBarChartHorizontal = new Chart(ctxBarHorizontal, {
            type: 'bar', // Specify bar chart type
            data: {
                labels: alertsLabels,
                datasets: [{
                    label: 'Status Count', // This dataset label is what Chart.js uses when it generates
                    // the legend entries and also what appears in tooltips. However, since we have only
                    // one dataset, it may not be necessary to display it, so below in
                    // "options > plugings" we're hiding the legend.
                    data: alertsDataValues,
                    backgroundColor: purpleGradient,
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y', // This option makes the bars horizontal instead of vertical
                plugins: {
                    title: {
                        display: true,
                        text: 'Analyse de la fréquence des alertes'
                    },
                    legend: {
                        display: false // Hide legend since we have only one dataset
                    }
                },
                scales: {
                    x: { // Since the bars are horizontal, the x-axis represents the count of vehicles
                        beginAtZero: true, // Ensure the y-axis starts at zero
                        title: {
                            display: true,
                            text: 'Nombre d\'alertes'
                        }
                    }
                }
            }
        });
    }

    // this turns alertsData into and object with keys as "type" and values as the count of each type.
    function getAlertsDataTypes(alertsData) {
        const dataTypes = {};
        
        alertsData.forEach(alert => {
            const type = alert.type;
            dataTypes[type] = (dataTypes[type] || 0) + 1;
        });
        
        return dataTypes;
    }

    function sortAlertsDescending(obj) {
        return Object.fromEntries(
            Object.entries(obj).sort((a, b) => b[1] - a[1])
        );
    }

    // # Line Chart

    const alertsDataTime = alertsData.map(item => {
        return {
            occurred_at: item.occurred_at
        };
    });

    const chartData = getAlertsByHour(alertsDataTime);
    // → [{ x: "2026-02-04T12", y: 1 }, { x: "2026-02-04T15", y: 4 }]

    let myLineChart // store the line chart instance
    renderLineChart(chartData);

    function renderLineChart(chartData) {
        const ctxLine = document.getElementById('lineChart').getContext('2d');

        // If chart already exists, update data and redraw
        if(myLineChart) {
            myLineChart.data.labels = dataLabels;
            myLineChart.data.datasets[0].data = dataValues;
            myLineChart.data.datasets[0].backgroundColor = dataColors;
            myLineChart.update(); // Triggers re-render
            return;
        }
        
        myLineChart = new Chart(ctxLine, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Number of Alerts',
                    data: chartData,
                    fill: false, // if you want to fill the area under the line, set this to true and add a backgroundColor property with the desired color
                    borderColor: '#8456CE',
                    tension: 0.1 // Adjust the tension for smoother or sharper curves (0 for straight lines, higher values for more curvature)
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Nombre d\'alertes par heure'
                    },
                    legend: {
                        display: false // Hide legend since we have only one dataset
                    }
                },
                scales: {
                    x: { type: 'time', time: { unit: 'hour' } },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Nombre d\'alertes'
                        }
                    }
                }
            }
        });
    }

    function getAlertsByHour(alertsDataTime) {
        const hourly = {};
        alertsDataTime.forEach(dataTime => {
            // Extract the hour from the "occurred_at" timestamp (e.g. "2026-02-04T17:20:06.000000Z" → "2026-02-04T17")
            const date = new Date(dataTime.occurred_at);
            const hour = date.toISOString().slice(0, 13);  // YYYY-MM-DDTHH
            
            // Count the number of alerts for each hour
            hourly[hour] = (hourly[hour] || 0) + 1;
        });

        return Object.entries(hourly)
            .sort((a, b) => a[0].localeCompare(b[0])) // Sort the entries by hour in ascending order
            .map(([label, count]) => ({ x: label, y: count })); // Convert to the format required by Chart.js (e.g. [{ x: "2026-02-04T17", y: 2 }, ...])
        // {"2026-02-05T07": 3, ...} becomes [{ x: "2026-02-05T07", y: 3 }, ...]
    }
</script>
</html>